# Правила разработки

## TDD подход

**Тесты первыми** (RED → GREEN → REFACTOR):
- Для каждого нового модуля сначала создаём `Tests/<Module>Tests/<Module>Tests.swift` с базовыми кейсами
- Затем пишем реализацию
- Проект кроссплатформенный - сборка на Linux обязательна

## Работа с ветками

Для каждой новой задачи создаём отдельную feature-ветку:

```bash
# Создание новой ветки для задачи
git checkout -b feature/task-name

# После завершения работы и прохождения тестов
git push -u origin feature/task-name
# Создаём Pull Request через GitHub CLI или веб-интерфейс
```

Работаем в ветке до полного завершения задачи и прохождения всех тестов. Только после этого мержим в `main`. Это позволяет держать `main` всегда в рабочем состоянии и облегчает code review.

## Кросс-платформенная проверка

- Используем `#if os(macOS)` / `#if os(Linux)` только там, где неизбежно
- Регулярно собираем проект на Linux через Docker:
  ```bash
  docker run --rm -v $(pwd):/code swift:6.0 bash -c "cd /code && swift build"
  ```

### Новые зависимости/фреймворки

**ОБЯЗАТЕЛЬНАЯ проверка на Linux ПЕРЕД использованием:**

1. Если настроен GitHub Actions:
   - Попросить пользователя запустить/проверить логи CI
   - Убедиться что сборка проходит на Linux

2. Если нет CI:
   - Попросить manual проверку на VPS/Docker
   - Выполнить `swift build && swift test` на Linux

**Только после успешной проверки** начинать использовать новую зависимость в коде.

## Логирование

**На каждом внешнем вызове** (Telegram, AI, Bot):
- Перед операцией: `logger.info("Fetching unread chats...")`
- После операции: `logger.info("Fetched \(count) chats")` или `logger.error("Failed to fetch: \(error)")`

## Обработка ошибок

- Все сетевые вызовы оборачиваем в `do-catch`
- Используем кастомные enum-ошибки: `enum ChatFetcherError: Error`

## Стиль кода

- **Отступы**: 4 пробела
- **Naming**: camelCase для переменных, PascalCase для типов
- **Асинхронность**: Swift Concurrency (async/await) для сетевых вызовов
- **Комментарии**: на русском языке для бизнес-логики, на английском для технических деталей
- **Обработка ошибок**: используем кастомные enum с associated values для контекста
- **Документация моделей внешних API**: НЕ добавлять JSON примеры и избыточную документацию для моделей внешних API (TDLib, OpenAI и т.д.) - они быстро устаревают. Только краткое описание назначения + ссылка на официальную документацию (если есть). Планируется автогенерация из схем.

## Чеклист перед коммитом

Перед созданием коммита:

1. **Записать сессию в [CHANGELOG.md](CHANGELOG.md)** (в начало файла):
   - Подробное описание что сделали
   - Список коммитов
   - Добавленные/завершенные задачи
   - **Важно:** только писать, не читать весь файл (экономия токенов)

2. **Актуализировать [TASKS.md](TASKS.md)**:
   - Отметить выполненные подзадачи (пока фича не готова)
   - Завершенные фичи → краткое резюме + ссылка на CHANGELOG
   - Добавить новые задачи
   - Обновить приоритеты

3. **Проверить критичный контекст** - если в ходе работы обнаружено:
   - Изменились требования деплоя, команды, конфигурация → обновить [DEPLOY.md](DEPLOY.md)
   - Изменились требования установки для macOS → обновить [SETUP.md](SETUP.md)
   - Изменилась архитектура, модули, паттерны → обновить [ARCHITECTURE.md](ARCHITECTURE.md)
   - Нашли и решили новую проблему → обновить [TROUBLESHOOTING.md](TROUBLESHOOTING.md)
   - Изменились API credentials или переменные окружения → обновить [CREDENTIALS.md](CREDENTIALS.md)

4. **Проверить тесты**: `swift test`

5. **Проверить сборку**: `swift build`

## Git коммиты

- Сообщения коммитов на **русском языке**
- **НЕ добавлять** "Generated with Claude Code" или "Co-Authored-By: Claude"
- Формат: краткое описание, затем список изменений через дефис
- Коммитить логически связанные изменения вместе

### ВАЖНО: Разделяй коммиты

- Изменения в коде (`Sources/`, `Tests/`) - отдельный коммит
- Изменения в документации (`CLAUDE.md`, `DEPLOY.md`, `TASKS.md`) - отдельный коммит
- Это упрощает code review и позволяет откатывать изменения независимо

## Зависимости

- Swift 6
- Зависимости обновлены ≤ 6 мес.
- Минимум сторонних библиотек
- Секреты — только из env/конфига, не в коде

## Архитектура

- Изменения > 2 файлов или смена архитектуры — сначала короткий план/RFC
- Публичные контракты не менять без тестов
- Если правок много — сначала план

См. [ARCHITECTURE.md](ARCHITECTURE.md) для деталей архитектуры.
